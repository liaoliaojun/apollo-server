{
  "owner": {
    "author": "了了君",
    "email": "1030219089a@gamil.com",
    "website": "https://liaoliaojun.com"
  },
  "articles": [
    {
      "article_id": "yIK3W2kOCA",
      "title": "test1",
      "content": "test-content",
      "views": 1,
      "date": "20201001 12:38",
      "time_stamp": 1601528515269,
      "like_count": 0,
      "like_ips": [],
      "tags": []
    },
    {
      "article_id": "WtLSgxZ-x",
      "title": "test1",
      "content": "test-content",
      "views": 1,
      "date": "20201001 12:38",
      "time_stamp": 1601528515264,
      "like_count": 0,
      "like_ips": [],
      "tags": []
    },
    {
      "article_id": "wpfVxnjWu",
      "title": "test1",
      "content": "test-content",
      "views": 1,
      "date": "20201001 12:38",
      "time_stamp": 1601528478920,
      "like_count": 0,
      "like_ips": [],
      "tags": []
    },
    {
      "article_id": "pn6KrXmfb",
      "title": "css实现管道流动特效",
      "marked_content": "示例：https://www.liaoliaojun.com/demo/light-pipe  \n\n源码：https://github.com/liaoliaojun/nuxt-apollo-example/commit/3588f60168100866b9e3f92ab53a735ceb383c1f\n\n",
      "content": "<p>示例：<a href=\"https://www.liaoliaojun.com/demo/light-pipe\">https://www.liaoliaojun.com/demo/light-pipe</a>  </p>\n<p>源码：<a href=\"https://github.com/liaoliaojun/nuxt-apollo-example/commit/3588f60168100866b9e3f92ab53a735ceb383c1f\">https://github.com/liaoliaojun/nuxt-apollo-example/commit/3588f60168100866b9e3f92ab53a735ceb383c1f</a></p>\n",
      "views": 30,
      "date": "九月11, 2020 10点53分",
      "time_stamp": 1599792808360,
      "like_count": 0,
      "like_ips": [],
      "bg_path": "",
      "is_top": false,
      "top_weight": 10,
      "tags": []
    },
    {
      "article_id": "d-p3EeqEq",
      "title": "博客前端代码已开源",
      "marked_content": "https://github.com/liaoliaojun/nuxt-apollo-example",
      "content": "<p><a href=\"https://github.com/liaoliaojun/nuxt-apollo-example\">https://github.com/liaoliaojun/nuxt-apollo-example</a></p>\n",
      "views": 63,
      "date": "八月11, 2020 09点49分",
      "time_stamp": 1597110599558,
      "like_count": 0,
      "like_ips": [],
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": []
    },
    {
      "article_id": "ZDnI24nky",
      "title": "Vue/Nuxtjs + Ts + GraphQL 最佳实践方案",
      "marked_content": "[Graphql-code-generator](https://github.com/dotansimha/graphql-code-generator)： **根据GraphQL的Schema，生成与业务对应的type(类型)，枚举(enum)，请求参数，返回结果**等，TypeScript根据该文件进行静态推导。  \n\n例如：根据Schema，Ts可以推导登录接口：\n - 登录接口的传参：username, password\n - 登录成功后的返回值：userid，name，phone等\n - 这时TS可以自动补全，校验字段名称，字段类型等。  \n\n首先NuxtJS接入TypeScript，使用[@nuxt/typescript-build](https://typescript.nuxtjs.org/zh-hant/guide/setup.html)  \n\n之后使用[graphql-code-generator](https://github.com/dotansimha/graphql-code-generator)生成ts代码。\n\n### [点击查看官方文档](https://graphql-code-generator.com/docs/plugins/typescript-vue-apollo)\n\n#### graphql-code-generator安装如下：\n  - yarn add -D @graphql-codegen/cli\n  - yarn add -D @graphql-codegen/typescript\n  - yarn add -D @graphql-codegen/typescript-operations\n  - yarn add -D @graphql-codegen/typescript-vue-apollo\n  - yarn add @vue/apollo-composable@4.0.0-alpha.7 -S\n  - yarn add @vue/composition-api@0.5.0 -S\n  - **更新：此PR[#1000](https://github.com/vuejs/vue-apollo/pull/1000)合并后@vue/composition-api可以使用最新版本**\n  - **vue/apollo-composable@4.0.0-alpha.8\n版本较旧，如无法发送请求，可使用以上版本@vue/composition-api@0.5.0**\n\n#### 根目录新建文件codegen.yml，内容如下\n```\ngenerates:\n  ./typeschema/index.ts:\n    schema: 你的GraphQL请求地址/graphql\n    documents:\n      # 匹配目录\n      - 'client/graphql/**.gql'\n      # - '!(src/**/auth/**.gql)' 排除目录\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-vue-apollo\n    config:\n      withHooks: true\n```\n#### 在package.json加入命令，执行 yarn run genschema, 就可以看到生成的ts代码了~\n```\n\"genschema\": \"graphql-codegen\"\n```\n\n**!!! 如果未使用apollo-composable载入apollo客户端，则需添加以下步骤：**\n\n#### apollo客户端使用apollo-boost\napollo客户端配置：client/apollo/index.ts\n```\nimport ApolloClient from 'apollo-boost'\n\nconst defaultClient = new ApolloClient({\n  uri: 'http://xx.com/graphql',\n  credentials: 'include',\n  fetchOptions: {\n    includeExtensions: true,\n  },\n})\n\nconst apolloClients: {[key: string]: any} = {\n  default: defaultClient,\n  defaultClient,\n}\n\nexport default function useApolloClient (arg?: any): typeof \napolloClients {\n  if (!arg) {\n    return apolloClients\n  }\n  if (typeof arg === 'string') {\n    return apolloClients[arg]\n  }\n  if (typeof arg === 'object') {\n    Object.assign(apolloClients, arg)\n  }\n  return apolloClients\n}\n```\n声明插件：plugins/provide-apollo-client.ts\n```\nimport {provide} from '@vue/composition-api'\nimport {ApolloClients} from '@vue/apollo-composable'\nimport useApolloClient from '~/apollo'\n\nexport default function apolloClient({app}: any) {\n  app.setup = () => {\n    provide(ApolloClients, {\n      default: useApolloClient().default,\n      defaultClient: useApolloClient().default,\n    })\n  }\n}\n```\nnuxt.config.js加入插件：\n```\nplugins: [\n  {src: '~/plugins/vue-composition-api'},\n  {src: '~/plugins/provide-apollo-client.ts'},\n]\n```\n\n都配置好后，就可以使用封装好的接口请求了~\n",
      "content": "<p><a href=\"https://github.com/dotansimha/graphql-code-generator\">Graphql-code-generator</a>： <strong>根据GraphQL的Schema，生成与业务对应的type(类型)，枚举(enum)，请求参数，返回结果</strong>等，TypeScript根据该文件进行静态推导。  </p>\n<p>例如：根据Schema，Ts可以推导登录接口：</p>\n<ul>\n<li>登录接口的传参：username, password</li>\n<li>登录成功后的返回值：userid，name，phone等</li>\n<li>这时TS可以自动补全，校验字段名称，字段类型等。  </li>\n</ul>\n<p>首先NuxtJS接入TypeScript，使用<a href=\"https://typescript.nuxtjs.org/zh-hant/guide/setup.html\">@nuxt/typescript-build</a>  </p>\n<p>之后使用<a href=\"https://github.com/dotansimha/graphql-code-generator\">graphql-code-generator</a>生成ts代码。</p>\n<h3 id=\"点击查看官方文档\"><a href=\"https://graphql-code-generator.com/docs/plugins/typescript-vue-apollo\">点击查看官方文档</a></h3>\n<h4 id=\"graphql-code-generator安装如下：\">graphql-code-generator安装如下：</h4>\n<ul>\n<li>yarn add -D @graphql-codegen/cli</li>\n<li>yarn add -D @graphql-codegen/typescript</li>\n<li>yarn add -D @graphql-codegen/typescript-operations</li>\n<li>yarn add -D @graphql-codegen/typescript-vue-apollo</li>\n<li>yarn add @vue/apollo-composable@4.0.0-alpha.7 -S</li>\n<li>yarn add @vue/composition-api@0.5.0 -S</li>\n<li><strong>更新：此PR<a href=\"https://github.com/vuejs/vue-apollo/pull/1000\">#1000</a>合并后@vue/composition-api可以使用最新版本</strong></li>\n<li><strong>vue/apollo-composable@4.0.0-alpha.8\n版本较旧，如无法发送请求，可使用以上版本@vue/composition-api@0.5.0</strong></li>\n</ul>\n<h4 id=\"根目录新建文件codegenyml，内容如下\">根目录新建文件codegen.yml，内容如下</h4>\n<pre><code>generates:\n  ./typeschema/index.ts:\n    schema: 你的GraphQL请求地址/graphql\n    documents:\n      # 匹配目录\n      - 'client/graphql/**.gql'\n      # - '!(src/**/auth/**.gql)' 排除目录\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-vue-apollo\n    config:\n      withHooks: true</code></pre>\n<h4 id=\"在packagejson加入命令，执行-yarn-run-genschema-就可以看到生成的ts代码了\">在package.json加入命令，执行 yarn run genschema, 就可以看到生成的ts代码了~</h4>\n<pre><code>\"genschema\": \"graphql-codegen\"</code></pre>\n<p><strong>!!! 如果未使用apollo-composable载入apollo客户端，则需添加以下步骤：</strong></p>\n<h4 id=\"apollo客户端使用apollo-boost\">apollo客户端使用apollo-boost</h4>\n<p>apollo客户端配置：client/apollo/index.ts</p>\n<pre><code>import ApolloClient from 'apollo-boost'\n\nconst defaultClient = new ApolloClient({\n  uri: 'http://xx.com/graphql',\n  credentials: 'include',\n  fetchOptions: {\n    includeExtensions: true,\n  },\n})\n\nconst apolloClients: {[key: string]: any} = {\n  default: defaultClient,\n  defaultClient,\n}\n\nexport default function useApolloClient (arg?: any): typeof \napolloClients {\n  if (!arg) {\n    return apolloClients\n  }\n  if (typeof arg === 'string') {\n    return apolloClients[arg]\n  }\n  if (typeof arg === 'object') {\n    Object.assign(apolloClients, arg)\n  }\n  return apolloClients\n}</code></pre>\n<p>声明插件：plugins/provide-apollo-client.ts</p>\n<pre><code>import {provide} from '@vue/composition-api'\nimport {ApolloClients} from '@vue/apollo-composable'\nimport useApolloClient from '~/apollo'\n\nexport default function apolloClient({app}: any) {\n  app.setup = () =&gt; {\n    provide(ApolloClients, {\n      default: useApolloClient().default,\n      defaultClient: useApolloClient().default,\n    })\n  }\n}</code></pre>\n<p>nuxt.config.js加入插件：</p>\n<pre><code>plugins: [\n  {src: '~/plugins/vue-composition-api'},\n  {src: '~/plugins/provide-apollo-client.ts'},\n]</code></pre>\n<p>都配置好后，就可以使用封装好的接口请求了~</p>\n",
      "views": 133,
      "date": "六月27, 2020 18点15分",
      "time_stamp": 1593252925971,
      "like_count": 0,
      "like_ips": [],
      "bg_path": "files/kT8y2qy_7-7c2ce7c3f81a321d.jpeg",
      "is_top": true,
      "top_weight": 11,
      "tags": []
    },
    {
      "article_id": "R-hMwO8qr",
      "title": "Ts常用泛型总结",
      "marked_content": "参考：\n  - GraphQL + codegen + vue-apollo生成的typescript代码\n\n## Omit (未包含)\n  - 用之前的 Pick 和 Exclude 进行组合, 实现忽略对象某些属性功能, 源码如下\n\n ```\ntype Omit<T, K> = Pick<T, Exclude<keyof T, K>>\n// 使用\ntype Foo = Omit<{name: string, age: number}, 'name'> // -> { age: number }\n```\n\n## Scalars\n  - 标量，GraphQL Schema的中转层，用于融合转换不同系统的类型（如Java与Ts的类型互转）。\n  ```\n type Scalars = {  \n      ID: string\n      String: string\n      Boolean: boolean\n      Int: number\n      Float: number\n      LocalDateTime: any\n }  \n\n const foo: Scalars['ID'] = '1' // yes\n const foo: Scalars['ID'] = 1   // no work, be 'string‘ type\n const foo: Scalars['String'] = '1' // yes\n  ```\n\n\n## Maybe\n  - 大概，或许，可能\n  -```\n  type Maybe<T> = T | null\n\n  const foo: Maybe<string> = '123'  // yes\n  const foo: Maybe<string> = null   // yes\n  const foo: Maybe<string> = 123    // Type '123' is not assignable to type 'Maybe<string>'.\n  ```  \n\n## Exact\n  - 准确的，严格的\n  - ```\n  type Exact<T extends { [key: string]: any }> = { [K in keyof T]: T[K] };\n\n  type inputType = {\n      a: number,\n      b: string,\n  }\n  ```\n 例子解析：\n  ```\n     //  例子：\n    const foo: Exact<{attr1: inputType, attr2: inputType}> = {\n        attr1: {\n          a: 1,\n          b: '2',\n        },\n        attr2: ...,\n    }\n  ```\n  ```\n  `<T extends { [key: string]: any }>`   \n T =  传入的值：{attr1: inputType, attr2: inputType}\n\n  {[K in keyof T]: T[K]} 解释:  \n 注：keyof 与 es6的object.keys()类似，获取【Key】值 \n\n 'K' 来自于遍历后的 'T'{attr1: inputType, attr2: inputType} 的【Key】值：[attr1, attr2] 所以 K = attr1, attr2\n\n  'T[K]' = {attr1: inputType, attr2: inputType}.attr1 或者 {attr1: inputType, attr2: inputType}.attr2\n  ```",
      "content": "<p>参考：</p>\n<ul>\n<li>GraphQL + codegen + vue-apollo生成的typescript代码</li>\n</ul>\n<h2 id=\"omit-未包含\">Omit (未包含)</h2>\n<ul>\n<li><p>用之前的 Pick 和 Exclude 进行组合, 实现忽略对象某些属性功能, 源码如下</p>\n<pre><code>type Omit&lt;T, K&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;\n// 使用\ntype Foo = Omit&lt;{name: string, age: number}, 'name'&gt; // -&gt; { age: number }</code></pre>\n</li>\n</ul>\n<h2 id=\"scalars\">Scalars</h2>\n<ul>\n<li><p>标量，GraphQL Schema的中转层，用于融合转换不同系统的类型（如Java与Ts的类型互转）。</p>\n<pre><code>type Scalars = {  \n  ID: string\n  String: string\n  Boolean: boolean\n  Int: number\n  Float: number\n  LocalDateTime: any\n}  \n\nconst foo: Scalars['ID'] = '1' // yes\nconst foo: Scalars['ID'] = 1   // no work, be 'string‘ type\nconst foo: Scalars['String'] = '1' // yes</code></pre>\n</li>\n</ul>\n<h2 id=\"maybe\">Maybe</h2>\n<ul>\n<li><p>大概，或许，可能</p>\n</li>\n<li><pre><code>type Maybe&lt;T&gt; = T | null\n\nconst foo: Maybe&lt;string&gt; = '123'  // yes\nconst foo: Maybe&lt;string&gt; = null   // yes\nconst foo: Maybe&lt;string&gt; = 123    // Type '123' is not assignable to type 'Maybe&lt;string&gt;'.</code></pre>\n</li>\n</ul>\n<h2 id=\"exact\">Exact</h2>\n<ul>\n<li><p>准确的，严格的</p>\n</li>\n<li><pre><code>type Exact&lt;T extends { [key: string]: any }&gt; = { [K in keyof T]: T[K] };\n\ntype inputType = {\n  a: number,\n  b: string,\n}</code></pre>\n<p>例子解析：</p>\n<pre><code> //  例子：\nconst foo: Exact&lt;{attr1: inputType, attr2: inputType}&gt; = {\n    attr1: {\n      a: 1,\n      b: '2',\n    },\n    attr2: ...,\n}</code></pre>\n<pre><code>`&lt;T extends { [key: string]: any }&gt;`   \nT =  传入的值：{attr1: inputType, attr2: inputType}\n\n{[K in keyof T]: T[K]} 解释:  \n注：keyof 与 es6的object.keys()类似，获取【Key】值 \n\n'K' 来自于遍历后的 'T'{attr1: inputType, attr2: inputType} 的【Key】值：[attr1, attr2] 所以 K = attr1, attr2\n\n'T[K]' = {attr1: inputType, attr2: inputType}.attr1 或者 {attr1: inputType, attr2: inputType}.attr2</code></pre>\n</li>\n</ul>\n",
      "views": 95,
      "date": "六月20, 2020 12点26分",
      "time_stamp": 1592627178874,
      "like_count": 0,
      "like_ips": [],
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": []
    },
    {
      "article_id": "K7SWW2UyH",
      "title": "Markdown服务端(NodeJS)过滤处理xss",
      "marked_content": "#### 博客文章使用markdown来编写，记录问题与解决方案。\n\n### 方案\n- 前端使用js库[`marked`](https://github.com/markedjs/marked)解析markdown语法。\n把俩种格式（原文，通过**marked**解析后的文本）给后台。\n\n- 后台（node）通过[`jsdom`](https://github.com/jsdom/jsdom)模拟浏览器环境，并通过js库[`dompurify`](https://github.com/cure53/DOMPurify) 处理 **前端用[marked](https://github.com/markedjs/marked)解析后的文本**，从而过滤掉可能会导致xss的标签。\n\n### Node端实现：\n```\n  import {JSDOM} from 'jsdom'\n  import DOMPurify from 'dompurify'\n\n  const {window} = new JSDOM('<!DOCTYPE html>')\n  const domPurify = DOMPurify(window)\n  \n  // 前端用marked解析后的原文\n  const content = `<p>123</p><img src=x onerror=alert(1)//>`\n\n  // 过滤xss标签\n  domPurify.sanitize(content)\n\n```\n\n### QA\n  - #### 为什么不用正则，而用DOMPurify过滤xss？\n  -- 因为浏览器很强大，可以解析各种写法的html，自闭合标签等。所以用正则去掉指定 **html标签，格式** 不靠谱，\n  ```\n   <img src=x onerror=alert(1)//>\n   <svg><g/onload=alert(2)//<p>\n  <p>abc<iframe//src=jAva&Tab;script:alert(3)>def</p> \n   <math><mi//xlink:href=\"data:x,<script>alert(4)</script>\n  ```     \n\n  - #### 为什么使用 jsdmo？\n  -- 因为DOMPurify是基于浏览器环境，所以Node端使用jsdom模拟浏览器环境。\n\n  - #### marked的sanitize方法去清除xss？\n  -- 官方已弃用该方法，因为会导致潜在的xss安全。通过js很难过滤掉全部。\n  -- 从这个仓库，侧面展现浏览器强大的解析能力: `使用最少的代码量绘制图形` https://github.com/alexzaworski/cssbattle-solutions\n  \n\n  - #### 前端处理好，在给后台。为何不这样处理？\n  -- 可以绕过前端发送攻击数据。永远不要相信前端给的数据。所以需要后端去过滤xss。\n  \n\n  - #### 服务端只提供markdown原文，让前台过滤处理？\n  -- 数据可能提供给多个客户端（app，小程序，web）。会导致各客户端都处理一遍数据。所以在入库时统一处理xss最佳。\n",
      "content": "<h4 id=\"博客文章使用markdown来编写，记录问题与解决方案。\">博客文章使用markdown来编写，记录问题与解决方案。</h4>\n<h3 id=\"方案\">方案</h3>\n<ul>\n<li><p>前端使用js库<a href=\"https://github.com/markedjs/marked\"><code>marked</code></a>解析markdown语法。\n把俩种格式（原文，通过<strong>marked</strong>解析后的文本）给后台。</p>\n</li>\n<li><p>后台（node）通过<a href=\"https://github.com/jsdom/jsdom\"><code>jsdom</code></a>模拟浏览器环境，并通过js库<a href=\"https://github.com/cure53/DOMPurify\"><code>dompurify</code></a> 处理 <strong>前端用<a href=\"https://github.com/markedjs/marked\">marked</a>解析后的文本</strong>，从而过滤掉可能会导致xss的标签。</p>\n</li>\n</ul>\n<h3 id=\"node端实现：\">Node端实现：</h3>\n<pre><code>  import {JSDOM} from 'jsdom'\n  import DOMPurify from 'dompurify'\n\n  const {window} = new JSDOM('&lt;!DOCTYPE html&gt;')\n  const domPurify = DOMPurify(window)\n\n  // 前端用marked解析后的原文\n  const content = `&lt;p&gt;123&lt;/p&gt;&lt;img src=x onerror=alert(1)//&gt;`\n\n  // 过滤xss标签\n  domPurify.sanitize(content)\n</code></pre>\n<h3 id=\"qa\">QA</h3>\n<ul>\n<li><h4 id=\"为什么不用正则，而用dompurify过滤xss？\">为什么不用正则，而用DOMPurify过滤xss？</h4>\n</li>\n<li><ul>\n<li>因为浏览器很强大，可以解析各种写法的html，自闭合标签等。所以用正则去掉指定 <strong>html标签，格式</strong> 不靠谱，<pre><code>&lt;img src=x onerror=alert(1)//&gt;\n&lt;svg&gt;&lt;g/onload=alert(2)//&lt;p&gt;\n&lt;p&gt;abc&lt;iframe//src=jAva&amp;Tab;script:alert(3)&gt;def&lt;/p&gt; \n&lt;math&gt;&lt;mi//xlink:href=\"data:x,&lt;script&gt;alert(4)&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><h4 id=\"为什么使用-jsdmo？\">为什么使用 jsdmo？</h4>\n</li>\n<li><ul>\n<li>因为DOMPurify是基于浏览器环境，所以Node端使用jsdom模拟浏览器环境。</li>\n</ul>\n</li>\n<li><h4 id=\"marked的sanitize方法去清除xss？\">marked的sanitize方法去清除xss？</h4>\n</li>\n<li><ul>\n<li>官方已弃用该方法，因为会导致潜在的xss安全。通过js很难过滤掉全部。</li>\n</ul>\n</li>\n<li><ul>\n<li>从这个仓库，侧面展现浏览器强大的解析能力: <code>使用最少的代码量绘制图形</code> <a href=\"https://github.com/alexzaworski/cssbattle-solutions\">https://github.com/alexzaworski/cssbattle-solutions</a></li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><h4 id=\"前端处理好，在给后台。为何不这样处理？\">前端处理好，在给后台。为何不这样处理？</h4>\n</li>\n<li><ul>\n<li>可以绕过前端发送攻击数据。永远不要相信前端给的数据。所以需要后端去过滤xss。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><h4 id=\"服务端只提供markdown原文，让前台过滤处理？\">服务端只提供markdown原文，让前台过滤处理？</h4>\n</li>\n<li><ul>\n<li>数据可能提供给多个客户端（app，小程序，web）。会导致各客户端都处理一遍数据。所以在入库时统一处理xss最佳。</li>\n</ul>\n</li>\n</ul>\n",
      "views": 97,
      "date": "六月14, 2020 12点51分",
      "time_stamp": 1592110261981,
      "like_count": 1,
      "like_ips": [
        "::ffff:52.184.24.211"
      ],
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": []
    },
    {
      "article_id": "0STFcjOU7",
      "title": "博客UI改版计划",
      "marked_content": "### 1. \"好看，舒服\"是第一要素\n- 前端开发者的基本技能\n\n### 2. 完美支持移动端\n- 移动端流量占比多\n\n### 3. 图片/文件\n- 支持本地上传，URL链接，粘贴等上传方式\n- <https://pawoo.net/web/getting-started> 获取素材，用于文章背景图\n\n### 4. 留言/评论功能\n\n### 5. 记录更新日志\n\n### 6. 友链\n\n\n### 参考 https://www.yevpt.com/",
      "content": "<h3 id=\"1-好看，舒服是第一要素\">1. \"好看，舒服\"是第一要素</h3>\n<ul>\n<li>前端开发者的基本技能</li>\n</ul>\n<h3 id=\"2-完美支持移动端\">2. 完美支持移动端</h3>\n<ul>\n<li>移动端流量占比多</li>\n</ul>\n<h3 id=\"3-图片文件\">3. 图片/文件</h3>\n<ul>\n<li>支持本地上传，URL链接，粘贴等上传方式</li>\n<li><a href=\"https://pawoo.net/web/getting-started\">https://pawoo.net/web/getting-started</a> 获取素材，用于文章背景图</li>\n</ul>\n<h3 id=\"4-留言评论功能\">4. 留言/评论功能</h3>\n<h3 id=\"5-记录更新日志\">5. 记录更新日志</h3>\n<h3 id=\"6-友链\">6. 友链</h3>\n<h3 id=\"参考-httpswwwyevptcom\">参考 <a href=\"https://www.yevpt.com/\">https://www.yevpt.com/</a></h3>\n",
      "views": 242,
      "date": "六月01, 2020 10点59分",
      "like_count": 10,
      "like_ips": [
        "::ffff:112.224.33.150",
        "::ffff:111.199.184.23",
        "::ffff:223.104.3.190",
        "::ffff:220.194.43.2",
        "::ffff:124.64.18.184",
        "::ffff:223.104.3.132",
        "::ffff:111.193.194.57",
        "::ffff:183.67.62.213",
        "::ffff:111.199.190.12",
        "::ffff:47.56.227.12"
      ],
      "bg_path": "files/ugxTeJOhq-727525.png",
      "is_top": true,
      "top_weight": 21,
      "tags": [
        "改版",
        "计划"
      ]
    },
    {
      "article_id": "G_X4wEdGB",
      "title": "如何处理textarea中的<tab>？",
      "marked_content": " ```\nconst tab = (e: any) => {\n        if (e.keyCode === 9) {\n          // vue 写法\n          const textarea = this.$refs.textareaInput\n          // composition-api用法：\n          // const textarea = ctx.refs.textareaInput\n\n          const start = textarea.selectionStart\n          const end = textarea.selectionEnd\n\n          const target = e.target\n          const value = target.value\n\n          // set textarea value to: text before caret + tab + text after caret\n          target.value = value.substring(0, start) + '  ' + value.substring(end)\n\n          // put caret at right position again (add one for the tab)\n          textarea.selectionStart = textarea.selectionEnd = start + 2\n\n          // prevent the focus lose\n          e.preventDefault()\n        }\n      }\n```",
      "content": "<pre><code>const tab = (e: any) =&gt; {\n       if (e.keyCode === 9) {\n         // vue 写法\n         const textarea = this.$refs.textareaInput\n         // composition-api用法：\n         // const textarea = ctx.refs.textareaInput\n\n         const start = textarea.selectionStart\n         const end = textarea.selectionEnd\n\n         const target = e.target\n         const value = target.value\n\n         // set textarea value to: text before caret + tab + text after caret\n         target.value = value.substring(0, start) + '  ' + value.substring(end)\n\n         // put caret at right position again (add one for the tab)\n         textarea.selectionStart = textarea.selectionEnd = start + 2\n\n         // prevent the focus lose\n         e.preventDefault()\n       }\n     }</code></pre>\n",
      "views": 77,
      "date": "五月31, 2020 02点01分",
      "like_count": 3,
      "like_ips": [
        "::ffff:124.64.18.184",
        "::ffff:183.67.62.213",
        "::ffff:111.199.190.12"
      ],
      "bg_path": "files/qlZPmcotX-833981.png",
      "is_top": true,
      "top_weight": 51,
      "tags": [
        "tab",
        "code"
      ]
    },
    {
      "article_id": "changelog",
      "title": "更新记录（changelog）",
      "marked_content": "### 新功能 - 2020.07.12\n- 全面使用graphql-codegen\n\n###  Bug 修复 - 2020.06.06\n- 移动端兼容，添加导航\n- 服务端日期时间\n\n###  新功能 - 2020.06.05\n- 添加更新日志模块\n- 文章：处理转换浏览量，点赞数，时间戳\n- 设置文章首页轮播展示，展示权重\n\n###  新功能 - 2020.06.04\n- 首页列表，详情样式改造完成\n- 支持移动端web\n- 添加返回功能\n- 切换页面滚动条置顶\n\n###  新功能 - 2020.05.31\n- 增加上传文件功能（本地上传，网络链接上传）\n- 设置文章页面的Meta，Title\n\n###  新功能 - 2020.05.30\n- 添加编辑文章时Tab键功能，当前光标后添加俩个空格\n- 密码存入localStorage，自动读取。验证增删改，文件上传等权限。\n\n###  新功能 - 2020.05.29\n- 文章添加展开全文功能\n- 记录访客信息",
      "content": "<h3 id=\"新功能---20200712\">新功能 - 2020.07.12</h3>\n<ul>\n<li>全面使用graphql-codegen</li>\n</ul>\n<h3 id=\"bug-修复---20200606\">Bug 修复 - 2020.06.06</h3>\n<ul>\n<li>移动端兼容，添加导航</li>\n<li>服务端日期时间</li>\n</ul>\n<h3 id=\"新功能---20200605\">新功能 - 2020.06.05</h3>\n<ul>\n<li>添加更新日志模块</li>\n<li>文章：处理转换浏览量，点赞数，时间戳</li>\n<li>设置文章首页轮播展示，展示权重</li>\n</ul>\n<h3 id=\"新功能---20200604\">新功能 - 2020.06.04</h3>\n<ul>\n<li>首页列表，详情样式改造完成</li>\n<li>支持移动端web</li>\n<li>添加返回功能</li>\n<li>切换页面滚动条置顶</li>\n</ul>\n<h3 id=\"新功能---20200531\">新功能 - 2020.05.31</h3>\n<ul>\n<li>增加上传文件功能（本地上传，网络链接上传）</li>\n<li>设置文章页面的Meta，Title</li>\n</ul>\n<h3 id=\"新功能---20200530\">新功能 - 2020.05.30</h3>\n<ul>\n<li>添加编辑文章时Tab键功能，当前光标后添加俩个空格</li>\n<li>密码存入localStorage，自动读取。验证增删改，文件上传等权限。</li>\n</ul>\n<h3 id=\"新功能---20200529\">新功能 - 2020.05.29</h3>\n<ul>\n<li>文章添加展开全文功能</li>\n<li>记录访客信息</li>\n</ul>\n",
      "views": 330,
      "date": "五月28日, 2020 22点13分",
      "like_count": 0,
      "like_ips": [],
      "bg_path": "files/DWP0x1Tce-727523.png",
      "is_top": true,
      "top_weight": 1,
      "tags": []
    },
    {
      "article_id": "XuttbziFL",
      "title": "使用Nuxt + Apollo Graphql/Axios/Http/Https生成网站地图(sitemap.xml)",
      "marked_content": "### 2020.06.14更新Apollo/Graphql获取方式：\n#### 使用`apollo-boost`封装apollo请求，弃用`vue-apollo，apollo-clinet`，`node-fetch`用于服务端fetch。\n\n`yarn add apollo-boost - S`  \n`yarn add node-fetch - S`\n\n`root: /apollo/index.js`的配置如下\n```\nimport ApolloClient from 'apollo-boost'\n// node-fetch用于Nuxt的Node端使用\nimport fetch from 'node-fetch'\n\nconst defaultClient = new ApolloClient({\n  uri: 'https://api.liaoliaojun.com/graphql',\n  fetch,\n})\n\nconst apolloClients = {\n  default: defaultClient,\n  defaultClient,\n}\n\nexport default function useApolloClient (arg) {\n  if (!arg) {\n    return apolloClients\n  }\n  if (typeof arg === 'string') {\n    return apolloClients[arg]\n  }\n  if (typeof arg === 'object') {\n    Object.assign(apolloClients, arg)\n  }\n}\n\n```\n\n\n`nuxt.config.js`的配置如下\n```\n  import gql from 'graphql-tag'\n  // 引入`root: /apollo/index.js`\n  import useApolloClient from './apollo/'\n  \n  export default {\n    // 设置网站地图\n    sitemap: {\n      path: '/sitemap.xml',\n      gzip: true,\n      routes: async () => {\n        const query = gql`\n          query queryArticles {\n            result: articles {\n              # 文章id\n              article_id\n            }\n          }\n        `\n        return await useApolloClient().defaultClient.query({\n          query,\n        }).then(res => {\n          return (res.data.result || []).map((article) => `/article/${article.article_id}`)\n        }).catch((error) => console.log(`dynamic routes error:   ${error}`))\n      },\n    },\n  }\n```\n\n\n#### 原文：\n### 第一步 : 安装@nuxtjs/sitemap\n```\nyarn add @nuxtjs/sitemap\n\n// 添加nuxtjs/sitemap至modules里面\nnuxt.config.js: \n{\n  modules: [\n    '@nuxtjs/sitemap',\n  ],\n}\n```\n### 第二步 : 使用axios模拟graphql请求\n#### 由于昨天睡的太晚（改日再战apollo-client），决定使用axios模拟graphql请求数据。参考apollo-client的fetch模拟：https://graphql.org/graphql-js/graphql-clients/\n```\nimport axios from 'axios'\n\n// 添加配置文件\nnuxt.config.js: \n{\n   // 设置网站地图\n  sitemap: {\n    path: '/sitemap.xml',\n    gzip: true,\n    routes: async () => {\n      // 手写graphql的query\n      const query = `\n        query queryArticles {\n          result: articles {\n            # 文章id\n            article_id\n          }\n        }\n      `\n      // 发送post请求并设置请求参数(query)，请求头(headers)\n      return await axios.post('https://api.liaoliaojun.com:3000/graphql', {query}, {\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      })\n      .then(res => {\n        return (res.data.data.result || []).map((article) => `/article/${article.article_id}`)\n      }).catch((error) => console.log(`dynamic routes error: ${error}`))\n    },\n  },\n}\n```\n### 访问sitemap查看是否生效\n- 地址：网站根目录 + /sitemap.xml（例如：https://liaoliaojun.com/sitemap.xml）\n",
      "content": "<h3 id=\"20200614更新apollographql获取方式：\">2020.06.14更新Apollo/Graphql获取方式：</h3>\n<h4 id=\"使用apollo-boost封装apollo请求，弃用vue-apollo，apollo-clinet，node-fetch用于服务端fetch。\">使用<code>apollo-boost</code>封装apollo请求，弃用<code>vue-apollo，apollo-clinet</code>，<code>node-fetch</code>用于服务端fetch。</h4>\n<p><code>yarn add apollo-boost - S</code><br><code>yarn add node-fetch - S</code></p>\n<p><code>root: /apollo/index.js</code>的配置如下</p>\n<pre><code>import ApolloClient from 'apollo-boost'\n// node-fetch用于Nuxt的Node端使用\nimport fetch from 'node-fetch'\n\nconst defaultClient = new ApolloClient({\n  uri: 'https://api.liaoliaojun.com/graphql',\n  fetch,\n})\n\nconst apolloClients = {\n  default: defaultClient,\n  defaultClient,\n}\n\nexport default function useApolloClient (arg) {\n  if (!arg) {\n    return apolloClients\n  }\n  if (typeof arg === 'string') {\n    return apolloClients[arg]\n  }\n  if (typeof arg === 'object') {\n    Object.assign(apolloClients, arg)\n  }\n}\n</code></pre>\n<p><code>nuxt.config.js</code>的配置如下</p>\n<pre><code>  import gql from 'graphql-tag'\n  // 引入`root: /apollo/index.js`\n  import useApolloClient from './apollo/'\n\n  export default {\n    // 设置网站地图\n    sitemap: {\n      path: '/sitemap.xml',\n      gzip: true,\n      routes: async () =&gt; {\n        const query = gql`\n          query queryArticles {\n            result: articles {\n              # 文章id\n              article_id\n            }\n          }\n        `\n        return await useApolloClient().defaultClient.query({\n          query,\n        }).then(res =&gt; {\n          return (res.data.result || []).map((article) =&gt; `/article/${article.article_id}`)\n        }).catch((error) =&gt; console.log(`dynamic routes error:   ${error}`))\n      },\n    },\n  }</code></pre>\n<h4 id=\"原文：\">原文：</h4>\n<h3 id=\"第一步--安装nuxtjssitemap\">第一步 : 安装@nuxtjs/sitemap</h3>\n<pre><code>yarn add @nuxtjs/sitemap\n\n// 添加nuxtjs/sitemap至modules里面\nnuxt.config.js: \n{\n  modules: [\n    '@nuxtjs/sitemap',\n  ],\n}</code></pre>\n<h3 id=\"第二步--使用axios模拟graphql请求\">第二步 : 使用axios模拟graphql请求</h3>\n<h4 id=\"由于昨天睡的太晚（改日再战apollo-client），决定使用axios模拟graphql请求数据。参考apollo-client的fetch模拟：httpsgraphqlorggraphql-jsgraphql-clients\">由于昨天睡的太晚（改日再战apollo-client），决定使用axios模拟graphql请求数据。参考apollo-client的fetch模拟：<a href=\"https://graphql.org/graphql-js/graphql-clients/\">https://graphql.org/graphql-js/graphql-clients/</a></h4>\n<pre><code>import axios from 'axios'\n\n// 添加配置文件\nnuxt.config.js: \n{\n   // 设置网站地图\n  sitemap: {\n    path: '/sitemap.xml',\n    gzip: true,\n    routes: async () =&gt; {\n      // 手写graphql的query\n      const query = `\n        query queryArticles {\n          result: articles {\n            # 文章id\n            article_id\n          }\n        }\n      `\n      // 发送post请求并设置请求参数(query)，请求头(headers)\n      return await axios.post('https://api.liaoliaojun.com:3000/graphql', {query}, {\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n      })\n      .then(res =&gt; {\n        return (res.data.data.result || []).map((article) =&gt; `/article/${article.article_id}`)\n      }).catch((error) =&gt; console.log(`dynamic routes error: ${error}`))\n    },\n  },\n}</code></pre>\n<h3 id=\"访问sitemap查看是否生效\">访问sitemap查看是否生效</h3>\n<ul>\n<li>地址：网站根目录 + /sitemap.xml（例如：<a href=\"https://liaoliaojun.com/sitemap.xml%EF%BC%89\">https://liaoliaojun.com/sitemap.xml）</a></li>\n</ul>\n",
      "views": 160,
      "date": "五月27日, 2020 23点55分",
      "like_count": 3,
      "like_ips": [
        "::ffff:124.64.18.184",
        "::ffff:183.67.62.213",
        "::ffff:47.56.227.12"
      ],
      "bg_path": "files/UxpNU7Lwa-792370.png",
      "is_top": true,
      "top_weight": 15,
      "tags": [
        "网站地图",
        "sitemap"
      ]
    },
    {
      "article_id": "fRLkRdJ6Z",
      "title": "博客问题记录",
      "marked_content": "### 文章列表应该采用倒序排序\n### 服务器时间时区不确定，应该前端或后端转换UTC时间（时间戳）为北京时间\n### 手绘风格背景应该JS生成。CSS无法实现不同间距的手绘线条。小图片会导致边界颜色突兀，可用超大图片（大于1920*1080）的图片去覆盖解决（文件太大，忽略）。\n### 添加修改，删除按钮\n### 密码自动保存在客户端进行填充\n###  文本域tab键处理\n### 高度问题",
      "content": "<h3 id=\"文章列表应该采用倒序排序\">文章列表应该采用倒序排序</h3>\n<h3 id=\"服务器时间时区不确定，应该前端或后端转换utc时间（时间戳）为北京时间\">服务器时间时区不确定，应该前端或后端转换UTC时间（时间戳）为北京时间</h3>\n<h3 id=\"手绘风格背景应该js生成。css无法实现不同间距的手绘线条。小图片会导致边界颜色突兀，可用超大图片（大于19201080）的图片去覆盖解决（文件太大，忽略）。\">手绘风格背景应该JS生成。CSS无法实现不同间距的手绘线条。小图片会导致边界颜色突兀，可用超大图片（大于1920*1080）的图片去覆盖解决（文件太大，忽略）。</h3>\n<h3 id=\"添加修改，删除按钮\">添加修改，删除按钮</h3>\n<h3 id=\"密码自动保存在客户端进行填充\">密码自动保存在客户端进行填充</h3>\n<h3 id=\"文本域tab键处理\">文本域tab键处理</h3>\n<h3 id=\"高度问题\">高度问题</h3>\n",
      "views": 99,
      "date": "五月26日, 2020 14点21分",
      "like_count": 2,
      "like_ips": [
        "::ffff:124.64.18.184",
        "::ffff:47.56.227.12"
      ],
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": []
    },
    {
      "article_id": "EF0CTeC77",
      "title": "如何实现“去中心化”世界",
      "content": "<h2 id=\"占坑，内容待填\">占坑，内容待填</h2>\n<h3 id=\"去中心化例子：\">“去中心化”例子：</h3>\n<ul>\n<li>以太坊</li>\n<li>Mastodon</li>\n<li>SOLID</li>\n</ul>\n",
      "views": 78,
      "date": "五月21日, 2020 10点10分",
      "like_count": 11,
      "like_ips": [
        "::ffff:123.118.4.176",
        "::ffff:124.64.18.184",
        "::ffff:47.56.227.12"
      ],
      "marked_content": "## 占坑，内容待填\n\n### “去中心化”例子：\n- 以太坊\n- Mastodon\n- SOLID",
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": [
        "去中心化"
      ]
    },
    {
      "article_id": "GMAMCscjD",
      "title": "xss测试",
      "content": "<p>xss</p>\n\n<style><style/><script>alert()//\n<img name=notify><style><style/><script>alert()//\n1221\n\nimg=valid_img_url&text=<img name%3dnotify><style><style%2F><script>alert()%2F%2F</style>",
      "views": 129,
      "date": "五月21日, 2020 10点10分",
      "like_count": 3,
      "like_ips": [
        "::ffff:114.241.247.164",
        "::ffff:220.194.43.2",
        "::ffff:124.64.18.184"
      ],
      "marked_content": "xss\n<script>\nalert(1)\n</script>\n<style><style/><script>alert()//\n<img name=notify><style><style/><script>alert()//\n1221\n\nimg=valid_img_url&text=<img name%3dnotify><style><style%2F><script>alert()%2F%2F",
      "bg_path": null,
      "is_top": false,
      "top_weight": 10,
      "tags": []
    }
  ],
  "uploads": [
    {
      "id": "r9VOYeH_G",
      "filename": "2b93614dbc76decf.jpeg",
      "mimetype": "",
      "encoding": "",
      "path": "files/r9VOYeH_G-2b93614dbc76decf.jpeg"
    },
    {
      "id": "PRa39CVjW",
      "filename": "c4a2c545226e53b8.jpeg",
      "mimetype": "",
      "encoding": "",
      "path": "files/PRa39CVjW-c4a2c545226e53b8.jpeg"
    },
    {
      "id": "zwSXu5RGY",
      "filename": "cover-1000-684fa370.jpeg",
      "mimetype": "",
      "encoding": "",
      "path": "files/zwSXu5RGY-cover-1000-684fa370.jpeg"
    },
    {
      "id": "g_WzLdAEw",
      "filename": "d8d4081f6bf129d1.png",
      "mimetype": "",
      "encoding": "",
      "path": "files/g_WzLdAEw-d8d4081f6bf129d1.png"
    },
    {
      "id": "kT8y2qy_7",
      "filename": "7c2ce7c3f81a321d.jpeg",
      "mimetype": "",
      "encoding": "",
      "path": "files/kT8y2qy_7-7c2ce7c3f81a321d.jpeg"
    }
  ],
  "visitors": [
    {
      "ip": "::ffff:120.245.114.241",
      "visit_time_local": "九月20, 2020 21点11分",
      "visit_time_stamp": 1600607470339
    },
    {
      "ip": "::ffff:66.249.79.80",
      "visit_time_local": "九月18, 2020 06点54分",
      "visit_time_stamp": 1600383240551
    },
    {
      "ip": "::ffff:203.137.167.22",
      "visit_time_local": "九月16, 2020 16点52分",
      "visit_time_stamp": 1600246366725
    },
    {
      "ip": "::ffff:61.93.139.166",
      "visit_time_local": "九月16, 2020 03点00分",
      "visit_time_stamp": 1600196428639
    },
    {
      "ip": "::ffff:103.230.228.26",
      "visit_time_local": "九月15, 2020 15点57分",
      "visit_time_stamp": 1600156648667
    },
    {
      "ip": "::ffff:183.67.58.139",
      "visit_time_local": "5/28/2020, 5:32:35 PM",
      "visit_time_stamp": 1590687155064
    },
    {
      "ip": "::ffff:66.249.64.229",
      "visit_time_local": "六月21, 2020 22点40分",
      "visit_time_stamp": 1592750423039
    },
    {
      "ip": "::ffff:47.56.227.12",
      "visit_time_local": "八月22, 2020 08点34分",
      "visit_time_stamp": 1598056487070
    },
    {
      "ip": "::ffff:183.230.164.221",
      "visit_time_local": "5/26/2020, 3:25:20 PM",
      "visit_time_stamp": 1590506720290
    },
    {
      "ip": "::ffff:34.84.167.228",
      "visit_time_local": "5/26/2020, 10:24:55 AM",
      "visit_time_stamp": 1590488695940
    },
    {
      "ip": "::ffff:183.67.59.193",
      "visit_time_local": "5/24/2020, 5:12:23 PM",
      "visit_time_stamp": 1590340343237
    },
    {
      "ip": "::ffff:117.136.30.4",
      "visit_time_local": "5/24/2020, 5:00:25 PM",
      "visit_time_stamp": 1590339625069
    },
    {
      "ip": "::ffff:119.84.158.12",
      "visit_time_local": "5/28/2020, 12:12:01 PM",
      "visit_time_stamp": 1590667921625
    },
    {
      "ip": "::ffff:183.67.57.46",
      "visit_time_local": "5/25/2020, 1:19:07 PM",
      "visit_time_stamp": 1590412747800
    },
    {
      "ip": "::ffff:223.104.248.10",
      "visit_time_local": "5/26/2020, 1:03:53 PM",
      "visit_time_stamp": 1590498233230
    },
    {
      "ip": "::ffff:223.104.250.59",
      "visit_time_local": "5/28/2020, 9:50:46 AM",
      "visit_time_stamp": 1590659446838
    }
  ]
}